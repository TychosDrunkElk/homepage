{
  "name": "grunt-hogan",
  "description": "a grunt task to compile/precompile hogan templates",
  "version": "0.3.0",
  "homepage": "https://github.com/automatonic/grunt-hogan",
  "author": {
    "name": "Elliott B. Edwards",
    "email": "elliott@automatonic.net",
    "url": "http://automatonic.net"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/automatonic/grunt-hogan.git"
  },
  "bugs": {
    "url": "https://github.com/automatonic/grunt-hogan/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/automatonic/grunt-hogan/blob/master/LICENSE-MIT"
    }
  ],
  "main": "grunt.js",
  "bin": {
    "grunt-hogan": "bin/grunt-hogan"
  },
  "engines": {
    "node": ">= 0.8.0"
  },
  "scripts": {
    "test": "grunt test"
  },
  "dependencies": {
    "hogan.js": "^3.0.2",
    "lodash": "^2.4.1",
    "underscore": "~1.4.4"
  },
  "devDependencies": {
    "grunt": "~0.4.5",
    "grunt-contrib-jshint": "^0.9.2",
    "grunt-shell": "^0.7.0"
  },
  "peerDependencies": {
    "grunt": "~0.4.5"
  },
  "keywords": [
    "gruntplugin",
    "hogan.js",
    "template",
    "mustache",
    "templating"
  ],
  "readme": "# grunt-hogan\n\na [grunt](http://gruntjs.com) task to precompile [mustache](http://mustache.github.io/) templates with [hogan.js](http://twitter.github.io/hogan.js/) \n\n[![Build status](https://ci.appveyor.com/api/projects/status/7sl7shna3qi0uo74)](https://ci.appveyor.com/project/automatonic/grunt-hogan)\n\n## Getting Started\n\n> NOTE: This documentation is for grunt version 0.4+. To work with version 0.3.x, see [here](https://github.com/automatonic/grunt-hogan/blob/grunt-0.3/README.md)\n\nInstall this grunt plugin next to your project's [Gruntfile.js][getting_started] with: `npm install grunt-hogan --save-dev`\n\nThen add this line to your project's `Gruntfile.js`:\n\n```javascript\ngrunt.loadNpmTasks('grunt-hogan');\n```\n\n`grunt-hogan` now uses standard [grunt file directives](http://gruntjs.com/configuring-tasks#files) for inputs and outputs.\n\nTo precompile a single `src` template into a single `dest` module:\n\n```javascript\ngrunt.initConfig({\n    //...\n    hogan: {\n        //desired target name\n        mytarget : {\n          //path to input template\n          src : 'view/chair.hogan',\n          //output path, relative to Gruntfile.js\n          dest : 'bandanna.js'\n        }\n    },\n    //...\n});\n```\n\n###Multiple input templates via patterns\n\n```javascript\ngrunt.initConfig({\n    //...\n    hogan: {\n        //desired target name\n        mytarget : {\n          //Wildcard of desired templates\n          src : 'view/**/*.hogan',\n          //output destination\n          dest : 'hulkingup.js'\n        }\n    },\n    //...\n});\n```\n\n###Multiple input template patterns\n\n```javascript\n//...\nmytarget : {\n    //...\n    src : ['view/wwf/*.hogan', 'view/wcw/*.hogan'],\n    //...\n}\n//...\n```\n\n##Options\n\n`grunt-hogan` has been updated to support grunt's\n[task- and target-specific options](http://gruntjs.com/configuring-tasks#options).\nIn this way you can DRY out your template tasks.\n\n##\"Binders\"\n\nA single target can compile multiple hogan templates into a single file. The active \"binder\" is\nresponsible for deciding how to join things together and what conventions/formats to use.\n\nIn general, most binders will result in a file containing a Javascript module, but this is customizable.\n\nIf a binder is not explicitly specified, the \"default\" binder will be used. \nThe \"default\" binder generates a javascript file\nthat is designed to work both as a node.js module and in the browser via a \n`<script/>` tag. Other built-in binders are:\n\n  * \"hulk\" - outputs results similar to hogan's \"hulk\" command line tool...which is \"vanilla\" javascript\n  * \"nodejs\" - exposes compiled templates as a node.js module\n  * \"amd\" - exposes compiled templates in amd format\n  * \"revealing\" - exposes compile templates via the revealing module pattern \n\nYou can also create your own binders. See the \"Custom Binders\" section below. If you think a binder is\nparticularly useful and want it to become \"built-in\", feel free to send a pull request.\n\nTo specify a binder, use the \"binderName\" option:\n\n```javascript\n//...\nmytarget : {\n    src : 'view/**/*.hogan',\n    dest : 'hulkingup.js',\n    options : { binderName: 'hulk' }\n}\n//...\n```\n###Custom Binders\n\nCustom binders start life as a binder template that is compiled with the \"bootstrap\" binder into a node.js style javascript module.\n`grunt-hogan` simply expects to be able to `require(...)` the module and access\na `templates` attribute that is an associative array from `[binderName]` to `Hogan.Template` instance.\n\n####Creating Custom Binders\n\nSee the `custombinder` and `twocustombinders` targets in the \n[example custombinder gruntfile](example/Gruntfile.custombinder.js) \nfor futher detail on creating and using custom binders.\n\n\n####Using Custom Binders\nTo use a *custom* binder, set the \"binderPath\" attribute to the desired javascript file:\n\n```javascript\n//...\noptions: {\n  binderPath : __dirname + '/my/custom/binders.js',\n  binderName : 'mybinder'\n}\n//...\n```\n\nIf `binderName` is unspecified, then the first binder in the module will be used (useful if you only have a single binder in your module): \n\n\n```javascript\n//...\noptions: {\n  binderPath : __dirname + '/my/custom/binders.js'\n}\n//...\n```\n\n###Using precompiled templates\n\nAs of version 0.2.2, all built in binders create javascript that functions similarly in intention, but varies with respect to the target use.\n\nGiven a precompile task like:\n\n```javascript\nmytarget : {\n  src : ['view/fist.html', 'view/foe.html', 'view/what.you.gonna.do.html'],\n  dest : 'templates.js',\n  options : { binderName : 'nodejs' }\n}\n```\nA node.js application could:\n\n```javascript\n//Load the module\nvar templates = require('./templates.js');\n\n//Render a template with a context object\nvar html1 = templates.fist({knuckles: true});\n\n//Render a template with context and partial templates\nvar html2 = templates.foe({}, {partialName: partialTemplateFromSomewhere});\n\n//Render a template with a non-variable-like name\nvar html3 = templates['what.you.gonna.do']({context:'catchphrase'});\n\n```\n\nAll of the binders (with the exceptions of special case binders like the bootstrap and \"hulk\") seek to expose the full api of the template render in this manner.\n\nAlso, if a partial parameter is not specified, the default render behavior is to make all the other templates in the binder (\"sibling templates\") available as partials in the render.\n\nOther templates will vary slightly in their syntax to support their purpose.\n\n###Template naming\n\nThe default behavior of `grunt-hogan` is to use the input templates file name (without the extension) as the name of the template in the output, precompiled result.\n\nThus an input of `view/yada.hogan` will be available as `templates.yada(...)`. However, there are plenty of scenarios where\none may want to customize this behavior. This is accomplished via the `nameFunc` option on a task:\n\n```javascript\nmytarget : {\n    src : './view/multi*.html',\n    dest : './temp/namefunc.js',\n    options : {\n      binderName: 'hulk',\n      \n      //Specify a custom name function\n      nameFunc: function(fileName) {\n        \n        //Grab the path package here locally for clarity\n        var _path = require('path');\n        \n        //'yada/yada/multi.1.js' -> 'multi.1'\n        var name = _path\n          .basename(\n            fileName, \n            _path.extname(fileName));\n            \n        //'multi.1' -> 'name_1'\n        return 'name_'+name[6];\n      }\n    }\n}\n```\n## Partial Templates\nHogan supports Partial Templates as defined by the [mustache spec](http://mustache.github.io/mustache.5.html).\n\nSay we have a template (defined in a file named `message.hogan`):\n```\n<p>Dear {{name}}, {{> mypartial}}</p>\n```\nAnd another template (defined in `mypartial.hogan`):\n```\n<em>{{text}}</em>\n```\nAssuming you use a `grunt-hogan` target to compile both these templates into a single module, you end up with a template render object something like:\n```javascript\n{\n    message: func(...){...},\n    mypartial: func(...){...}\n}\n```\nWe want Hogan to now expand the `mypartial` template and interpret the `message` template as:\n```\n<p>Dear {{name}}, <em>{{text}}</em></p>\n```\nBut how do we give Hogan what it needs to resolve the `mypartial` template? `grunt-hogan` supports this through three features:\n### 1. \"Sibling\" Partial Templates\nBy default, if you call the render function with just a context object:\n```javascript\ntemplate.message({name:'Hulk', text:'Have a nice day!'});\n```\n`grunt-hogan` will make the `mypartial` template available to the `message` template *automatically*. \nThis will happen if:\n\n  1. `message.hogan` and `mypartial.hogan` were bound together into a single template render module\n  2. The `nameFunc` (if specified) preserves the partial name `mypartial` mentioned in the `message.hogan` template\n\nSince `grunt-hogan` exposes the render as a function, this is the intended \"common practice\" for partial templates. \n\n*If you want a partial template to be automatically available, bind it as a sibling template with the template that depends on it.*\n\n### 2. Explicit Partial Templates\nTo disable the default behavior of \"Sibling\" Partial Templates, you simply specify the second parameter:\n```javascript\ntemplate.message(\n    {name:'Hulk', text:'Have a nice day!'}, //context\n    {mypartial: getMyPartialFromSomewhere()} //partials\n    );\n```\nBut now you are on your own when resolving the `Hogan.Template` objects passed through to the Hogan render. Hogan will use the passed partials only if they are valid `Hogan.Template` instances.\n### 3. Use the `exposeTemplates` task option\nIf you don't know at template compile time what partials are needed, \nand/or can't/won't put templates together as \"Siblings\", then you will need a way to retrieve the actual \n`Hogan.Template` instances from `grunt-hogan` modules. \nTo do this, specify the `exposeTemplates` option on the compile task. \nDoing so makes the actual templates available as a `template` property on the module:\n```javascript\n{\n    message: func(...){...},\n    mypartial: func(...){...},\n    templates: { message: {...}, mypartial: {...}}\n}\n```\nUsing this, you can pass the actual `Hogan.Template` instance to wherever it is needed (with the \"Explicit Partial Templates\" mentioned above, for example).\n## Examples\n * See [an example gruntfile](example/Gruntfile.js)\n\n## Contributing\nIn lieu of a formal styleguide, take care to maintain the existing coding style. Add unit tests for any new or changed functionality. Lint and test your code using [grunt][grunt].\n\n## Release History\n * 0.3.- - [in progress](https://github.com/automatonic/grunt-hogan/issues?milestone=3&state=open)\n * 0.2.2 - Binder template overhaul\n   * Added partial support on render functions\n   * Sibling partials by default\n   * *Breaking changes for precompiled template API*\n * 0.2.1 - AMD Binder\n   * Now supports use of \"sibling templates\" (defined within the same binder) as partials\n   * *Breaking change* - Now exports a render function instead of the full template\n * 0.1.1 - [*Breaking Changes* and Custom Binder Support](https://github.com/automatonic/grunt-hogan/issues?milestone=1)\n   * \"render\" directive has [been discarded](https://github.com/automatonic/grunt-hogan/issues/8)\n   * \"options\" notation has been discarded (supply attributes directly as keys on the target)\n\n##Acknowledgements\n * a comment by \"baz\" [here](http://soenkerohde.com/2012/02/node-js-server-side-compile-hogan-js-templates/) pointed me in the right direction\n\n## License\nCopyright (c) 2014 Elliott B. Edwards  \nLicensed under the MIT license.\n\n[grunt]: http://gruntjs.com/\n[getting_started]: https://github.com/gruntjs/grunt/wiki/Getting-started\n",
  "readmeFilename": "README.md",
  "_id": "grunt-hogan@0.3.0",
  "_from": "grunt-hogan@~0.3.0"
}
